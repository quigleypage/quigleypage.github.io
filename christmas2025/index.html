<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Santa's Wild Ride</title>
    <style>
        /* CSS Styles */
        html {
            touch-action: manipulation;
            background: #ffe8d6; /* Light, warm background */
            overflow: hidden;
        }
        body {
            margin: 0;
            padding: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            font-family: 'Comic Neue', cursive, sans-serif; /* Warmer, rounder font */
            color: #333;
            touch-action: none;
            background-color: #f8f0e3; /* Softer background color */
            background-image: url('background.png'); /* Subtle, stylized snowflake background */
            background-size: cover;
            background-position: center;
            overflow: hidden;
        }
        #gameContainer {
            position: relative;
            width: 600px; /* Adjust for landscape */
            max-width: 95vw; /* Responsive width */
            height: 400px; /* Adjust for landscape */
            max-height: 95vh; /* Responsive height */
            background: rgba(255, 255, 255, 0.7); /* Lighter container */
            border-radius: 10px; /* Soft rounded corners */
            box-shadow: inset 0 0 15px rgba(0, 0, 0, 0.1), 0 0 10px rgba(100, 100, 100, 0.1); /* Softer shadow */
            overflow: hidden;
        }
        #gameCanvas {
            width: 100%;
            height: 100%;
        }
        #score {
            position: absolute;
            top: 10px;
            right: 10px; /* Position on the right for landscape */
            color: #348040; 
            font-size: 32px;
            z-index: 2;
            text-shadow: 1px 1px 2px #fff; /* Lighter text shadow */
        }
        #gameOver, #startScreen {
            position: absolute;
            /* Change to top-left based positioning */
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: #555;
            border-radius: 12px;
            text-align: center;
            box-shadow: 0 0 15px rgba(150, 150, 150, 0.5);
        }
        #gameOver {
            background: rgba(220, 20, 20, 0.95); /* Crimson red */
            color: white;
            display: none;
        }
        #startScreen {
            background: rgba(255, 240, 200, 0.95); /* Light, creamy background */
        }
        #startScreen h2 {
            margin-top: 0;
            font-size: 38px;
            text-shadow: 1px 1px 2px #fff;
        }
        button {
            background: #d4ac0d; /* Golden yellow */
            color: white;
            border: none;
            padding: 14px 28px;
            border-radius: 8px;
            cursor: pointer;
            margin-top: 20px;
            font-size: 20px;
            font-family: 'Comic Neue', cursive, sans-serif;
            box-shadow: 0 0 8px rgba(0, 0, 0, 0.2);
            transition: background-color 0.3s ease, transform 0.1s ease;
        }
        button:hover {
            background: #b7950b;
            transform: scale(1.03);
        }
        #gameOver h2 {
            margin-top: 0;
            font-size: 34px;
            text-shadow: 1px 1px 2px #fff;
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <canvas id="gameCanvas"></canvas>
        <div id="score">Distance: 0</div>
        <div id="startScreen">
            <h2>Santa's Wild Ride</h2>
            <p style="font-size: 18px; line-height: 1.6;">Tap or use arrow keys</p>
            <button id="startButton">Now, Dasher!</button>
        </div>
        <div id="gameOver">
            <h2>Ouch!</h2>
            <p style="font-size: 18px;">Final Distance: <span id="finalScore">0</span></p>
            <button id="restartButton">Try Again</button>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const scoreElement = document.getElementById('score');
        const gameOverElement = document.getElementById('gameOver');
        const startScreen = document.getElementById('startScreen');
        const finalScoreElement = document.getElementById('finalScore');

        // Set canvas size
        function resizeCanvas() {
            canvas.width = canvas.offsetWidth;
            canvas.height = canvas.offsetHeight;
        }
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);

        // Game variables
        let gameRunning = false;
        let score = 0;
        let level = 1;
        let santa = {
            x: 50, // Starting from the left
            y: canvas.height / 2 - 30, // Adjusted for vertical center
            width: 60, // Adjusted for landscape orientation
            height: 40, // Adjusted for landscape orientation
            speed: 5
        };

        let trees = []; // For snowy tree tops
        let obstacles = [];
        let lastTreeX = canvas.width; // Start generating trees from the right
        let viewportOffset = 0;

        // Load Santa image
        const santaImg = new Image();
        santaImg.src = 'santa_sleigh1-cropped.png';

        // Load drone image for obstacles
        const droneImg = new Image();
        droneImg.src = 'drone_landscape.png';
        let droneAspectRatio = 1; // Placeholder for the aspect ratio

        droneImg.onload = () => {
            // Calculate aspect ratio once the image is loaded
            droneAspectRatio = droneImg.naturalWidth / droneImg.naturalHeight;
        };

        // --- Audio Setup ---
        const bgMusic = new Audio("Santa's Wild Ride (1).mp3");
        bgMusic.loop = true; // Loop the music
        bgMusic.volume = 0.5; // Adjust volume as needed (0.0 to 1.0)

        // Function to start playing music (to be called after user interaction)
        function playBackgroundMusic() {
            bgMusic.play().catch(error => {
                console.log('Error playing music:', error);
                // Handle error or try to play again later
            });
        }

        // Game controls
        let movingUp = false;
        let movingDown = false;

        function handleTouch(e) {
            e.preventDefault();
            const touch = e.touches[0];
            const gameRect = canvas.getBoundingClientRect();
            const touchY = touch.clientY - gameRect.top;

            if (touchY < canvas.height / 2) {
                movingUp = true;
                movingDown = false;
            } else {
                movingUp = false;
                movingDown = true;
            }
        }

        function handleTouchEnd() {
            movingUp = false;
            movingDown = false;
        }

        canvas.addEventListener('touchstart', handleTouch);
        canvas.addEventListener('touchmove', handleTouch);
        canvas.addEventListener('touchend', handleTouchEnd);

        // Keyboard controls
        document.addEventListener('keydown', (e) => {
            if (e.key === 'ArrowUp') movingUp = true;
            if (e.key === 'ArrowDown') movingDown = true;
        });

        document.addEventListener('keyup', (e) => {
            if (e.key === 'ArrowUp') movingUp = false;
            if (e.key === 'ArrowDown') movingDown = false;
        });

        // Generate obstacles (drones) based on level
        function generateObstacle(x) {
            const topLimit = canvas.height / 3; // Drones allowed in top two-thirds
            const types = ['Horizontal', 'Vertical'];
            const type = types[Math.floor(Math.random() * types.length)];
            const size = 25 + Math.random() * 10;
            const y = Math.random() * (topLimit * 2 - size); // Restrict to top two-thirds

            obstacles.push({
                x: x,
                y: y,
                width: size,
                height: size,
                type: type,
                speed: 1.5 + Math.min(level * 0.4, 3),
                movementCounter: 0 // For movement patterns
            });
        }

        // --- Generate Snowy Christmas Trees ---
        function generateTree(xPos) {
            const minHeight = 60;
            const maxHeight = canvas.height / 3;
            const treeHeight = Math.floor(Math.random() * (maxHeight - minHeight + 1)) + minHeight;
            const treeWidth = Math.floor(Math.random() * (80 - 50 + 1)) + 50; // Width between 50 and 80
            const y = canvas.height - treeHeight;

            // Create a tree with multiple layers
            const numLayers = 3 + Math.floor(Math.random() * 3); // 3 to 5 layers
            const layers = [];
            for (let i = 0; i < numLayers; i++) {
                const layerWidth = treeWidth * (1 - i / numLayers);
                const layerHeight = treeHeight / numLayers;
                const layerY = y + treeHeight - layerHeight * (i + 1);

                layers.push({
                    x: xPos + (treeWidth - layerWidth) / 2,
                    y: layerY,
                    width: layerWidth,
                    height: layerHeight
                });
            }

            trees.push({
                x: xPos,
                y: y,
                width: treeWidth,
                height: treeHeight,
                layers: layers,
                color: getRandomTreeColor()
            });

            // Generate obstacles near a tree
            if (Math.random() < Math.min(0.3 + level * 0.05, 0.7)) {
                generateObstacle(xPos + treeWidth + 50); // Slightly ahead of the tree
            }
        }

        // Get a random green color for trees with slight variations
        function getRandomTreeColor() {
            const baseColors = ["#006400", "#228B22", "#008000", "#3CB371"]; // Dark greens
            const baseColor = baseColors[Math.floor(Math.random() * baseColors.length)];

            // Add slight variations to the base color
            const colorVariation = Math.floor(Math.random() * 21) - 10; // -10 to 10
            const r = Math.max(0, Math.min(255, parseInt(baseColor.substring(1, 3), 16) + colorVariation));
            const g = Math.max(0, Math.min(255, parseInt(baseColor.substring(3, 5), 16) + colorVariation));
            const b = Math.max(0, Math.min(255, parseInt(baseColor.substring(5, 7), 16) + colorVariation));

            return `rgb(${r}, ${g}, ${b})`;
        }

        // Update obstacle positions
        function updateObstacles() {
            const topLimit = canvas.height / 3;

            obstacles.forEach(obstacle => {
                obstacle.movementCounter += 0.05;

                switch (obstacle.type) {
                    case 'Horizontal':
                        obstacle.x += Math.sin(obstacle.movementCounter) * obstacle.speed;
                        break;
                    case 'Vertical':
                        obstacle.y += Math.sin(obstacle.movementCounter) * obstacle.speed;
                        break;
                }

                // Keep drones in the top two-thirds of the screen
                obstacle.y = Math.max(0, Math.min(topLimit * 2 - obstacle.height, obstacle.y));
            });

            obstacles = obstacles.filter(obstacle => obstacle.x > -50);
        }
        
        // Check collision with obstacles
        function checkObstacleCollision() {
            return obstacles.some(obstacle => {
                const relativeX = obstacle.x - viewportOffset; // Relative x position
                const distX = (santa.x + santa.width / 2) - (relativeX + obstacle.width / 2);
                const distY = (santa.y + santa.height / 2) - (obstacle.y + obstacle.height / 2);
                const combinedHalfWidths = santa.width / 2 + obstacle.width / 2;
                const combinedHalfHeights = santa.height / 2 + obstacle.height / 2;

                return Math.abs(distX) < combinedHalfWidths && Math.abs(distY) < combinedHalfHeights;
            });
        }

        // Check collision with trees
        function checkTreeCollision() {
            for (let i = 0; i < trees.length; i++) {
                const tree = trees[i];
                const relativeX = tree.x - viewportOffset;

                for (let j = 0; j < tree.layers.length; j++) {
                    const layer = tree.layers[j];
                    const relativeLayerX = layer.x - viewportOffset;

                    // Check if Santa is within the x-range of the layer
                    if (santa.x + santa.width > relativeLayerX && santa.x < relativeLayerX + layer.width) {
                        // Check for collision using the equation of a line (triangle's slope)
                        const slope = layer.height / (layer.width / 2);
                        const yAtSantaLeft = layer.y + slope * Math.abs(santa.x - relativeLayerX);
                        const yAtSantaRight = layer.y + slope * Math.abs(santa.x + santa.width - relativeLayerX);

                        if (santa.y + santa.height > yAtSantaLeft || santa.y + santa.height > yAtSantaRight) {
                            return true; // Collision detected
                        }
                    }
                }
            }
            return false; // No collision
        }

        // Game loop
        function update() {
            if (!gameRunning) return;

            if (movingUp && santa.y > 0) santa.y -= santa.speed; // Move up
            if (movingDown && santa.y < canvas.height - santa.height) santa.y += santa.speed; // Move down

            const scrollSpeed = 1.8 + Math.min(level * 0.3, 3); // Reduced scroll speed progression
            viewportOffset += scrollSpeed; // Horizontal scrolling
            score = Math.floor(viewportOffset / 10);
            level = Math.floor(score / 75) + 1; // Level up less frequently

            updateObstacles();

            // Generate trees from right to left
            while (lastTreeX < viewportOffset + canvas.width + 200) {
                generateTree(lastTreeX);
                lastTreeX += 100 + Math.random() * 80; // More varied spacing
            }

            if (checkObstacleCollision() || checkTreeCollision()) {
                gameOver();
            }

            trees = trees.filter(tree => tree.x > viewportOffset - 100);

            draw();
            requestAnimationFrame(update);
        }

        // --- Drawing Functions ---
        function drawTrees() {
            trees.forEach(tree => {
                tree.layers.forEach(layer => {
                    const x = layer.x - viewportOffset;
                    const y = layer.y;

                    // Draw the tree layer as a triangle
                    ctx.beginPath();
                    ctx.fillStyle = tree.color;
                    ctx.moveTo(x, y + layer.height);
                    ctx.lineTo(x + layer.width / 2, y);
                    ctx.lineTo(x + layer.width, y + layer.height);
                    ctx.closePath();
                    ctx.fill();

                    // Draw snow on top of the layer
                    ctx.beginPath();
                    ctx.fillStyle = '#FFFFFF'; // White for snow
                    ctx.moveTo(x + layer.width / 2, y);
                    ctx.lineTo(x + layer.width / 2 - 10, y + 10);
                    ctx.lineTo(x + layer.width / 2 + 10, y + 10);
                    ctx.closePath();
                    ctx.fill();
                });
            });
        }

        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Background color handled by CSS
            // Subtle snow effect
            ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
            for (let i = 0; i < 70; i++) {
                const y = Math.random() * canvas.height;
                const x = (viewportOffset * 0.1 + i * 10) % canvas.width; // Horizontal movement
                const size = Math.random() * 3;
                ctx.beginPath();
                ctx.arc(x, y, size, 0, Math.PI * 2);
                ctx.fill();
            }

            drawTrees(); // Draw the trees

            obstacles.forEach(obstacle => {
                const x = obstacle.x - viewportOffset;
                ctx.save();
                ctx.translate(x + obstacle.width / 2, obstacle.y + obstacle.height / 2);
                // No rotation for drones
                if (droneImg.complete) {
                    // Calculate new dimensions based on aspect ratio
                    let newWidth = obstacle.width;
                    let newHeight = newWidth / droneAspectRatio;
                    if (newHeight > obstacle.height) {
                        newHeight = obstacle.height;
                        newWidth = newHeight * droneAspectRatio;
                    }
                    ctx.drawImage(droneImg, -newWidth / 2, -newHeight / 2, newWidth, newHeight);
                } else {
                    // Fallback in case the image hasn't loaded yet
                    const colors = ['red', 'green', 'blue', 'yellow'];
                    ctx.fillStyle = colors[Math.floor(Math.random() * colors.length)];
                    ctx.fillRect(-obstacle.width / 2, -obstacle.height / 2, obstacle.width, obstacle.height);
                }
                ctx.restore();
            });

            // Draw Santa
            ctx.drawImage(santaImg, santa.x, santa.y, santa.width, santa.height);

            // Update score display
            scoreElement.textContent = `Distance: ${score}`;
        }

        function gameOver() {
            gameRunning = false;
            finalScoreElement.textContent = score;
            gameOverElement.style.display = 'flex'; // Use flex for centering
        }

        function startGame() {
            gameRunning = true;
            score = 0;
            level = 1;
            viewportOffset = 0;
            scoreElement.textContent = 'Distance: 0';
            santa.x = 50; // Start from the left
            santa.y = canvas.height / 2 - 30; // Adjusted for vertical center
            santa.speed = 5;
            trees = [];
            obstacles = [];
            lastTreeX = canvas.width; // Start generating trees from the right

            startScreen.style.display = 'none';
            gameOverElement.style.display = 'none';

            // Play music if not already playing
            if (bgMusic.paused) {
                playBackgroundMusic();
            }

            for (let x = canvas.width; x < canvas.width + 400; x += 200) {
                generateTree(x);
                lastTreeX = x;
            }

            update();
        }

        document.getElementById('startButton').addEventListener('click', startGame);
        document.getElementById('restartButton').addEventListener('click', startGame);

        draw();

        //prevent auto scroll on iOS
        window.addEventListener('scroll', function(e) {
            if (window.scrollY !== 0) {
                window.scrollTo(0, 0);
            }
        }, { once: true });
    </script>
</body>
</html>